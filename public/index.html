<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kho ƒê∆∞·ªùng B√≠ch Tuy·ªÅn ‚Äì V6 ONLINE</title>

  <!-- AI OCR -->
  <script src="https://unpkg.com/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f1f2f6;
      margin: 0;
      padding: 12px;
    }
    h2 {
      text-align: center;
      margin-bottom: 8px;
    }
    .search {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #aaa;
      margin-bottom: 10px;
    }
    .toolbar {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }
    .toolbar button {
      padding: 10px;
      border-radius: 8px;
      border: none;
      font-size: 14px;
      color: #fff;
    }
    .btn-import { background: #0984e3; }
    .btn-export { background: #e17055; }
    .btn-reset  { background: #d63031; }
    .btn-copy   { background: #e67e22; }
    .btn-excel  { background: #00b894; }

    .total {
      text-align: center;
      padding: 8px;
      background: #dff9fb;
      border-radius: 8px;
      margin-bottom: 10px;
      font-size: 16px;
      color: #22a6b3;
    }

    .card {
      background: #fff;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 10px;
      border-left: 6px solid transparent;
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .product-title {
      font-size: 16px;
      font-weight: bold;
    }
    .group {
      font-size: 12px;
      color: #555;
    }
    .unit-info {
      font-size: 11px;
      color: #888;
      margin-top: 2px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-top: 4px;
    }
    .row input {
      flex: 1;
    }
    input[type="number"] {
      padding: 6px;
      border-radius: 6px;
      border: 1px solid #bbb;
      font-size: 13px;
    }
    .label {
      font-size: 11px;
      color: #555;
    }
    .result {
      margin-top: 6px;
      font-size: 12px;
      color: #2d3436;
    }
    .result span.bold { font-weight: bold; }
    .sparkline {
      font-size: 11px;
      color: #636e72;
      margin-top: 3px;
    }

    .status {
      margin-top: 6px;
      font-size: 13px;
      color: #636e72;
      text-align: center;
    }

    /* m√†u nh√≥m */
    .card[data-group="ƒê∆∞·ªùng c√°t"]     { border-left-color:#e67e22; }
    .card[data-group="Ph√®n"]          { border-left-color:#e84393; }
    .card[data-group="Bi / ph·ª• ph·∫©m"] { border-left-color:#00b894; }

    /* overlay OCR */
    #ocrOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    #ocrBox {
      background: #fff;
      padding: 14px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 70%;
      overflow-y: auto;
      font-size: 13px;
    }
    #ocrBox h3 { margin-top: 0; }
    #ocrBox pre {
      white-space: pre-wrap;
      font-size: 11px;
    }
    #ocrBox button {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: none;
      margin-top: 8px;
      background: #0984e3;
      color: #fff;
    }

    /* l·ªãch s·ª≠ ng√†y */
    .history-box {
      margin-top: 10px;
      font-size: 12px;
      color: #636e72;
    }
    .history-box select {
      width: 100%;
      padding: 5px;
      border-radius: 6px;
      border: 1px solid #bbb;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <h2>üì¶ KHO ƒê∆Ø·ªúNG B√çCH TUY·ªÄN ‚Äì V6 ONLINE</h2>

  <input type="text" id="search" class="search" placeholder="T√¨m s·∫£n ph·∫©m..." oninput="renderList()">

  <div class="toolbar">
    <button class="btn-import" onclick="triggerImage('nhap')">üì• ·∫¢NH PHI·∫æU NH·∫¨P (AI t·ª± ƒë·ªçc)</button>
    <button class="btn-export" onclick="triggerImage('xuat')">üì§ ·∫¢NH PHI·∫æU XU·∫§T (AI t·ª± ƒë·ªçc)</button>
    <button class="btn-reset"  onclick="resetData()">üîÑ Reset d·ªØ li·ªáu ng√†y (0 t·ªìn / 0 nh·∫≠p / 0 xu·∫•t)</button>
    <button class="btn-copy"   onclick="copyReport()">üìÑ Copy b√°o c√°o g·ª≠i Zalo</button>
    <button class="btn-excel"  onclick="exportCSV()">üìä Xu·∫•t Excel (CSV)</button>
  </div>

  <div id="totalBox" class="total">ƒêang t·∫£i d·ªØ li·ªáu kho...</div>

  <div id="list"></div>

  <div class="history-box">
    <div><b>L·ªãch s·ª≠ t·ªìn kho (ƒë√≥ng ng√†y):</b></div>
    <button style="margin-top:5px;padding:6px 10px;border-radius:6px;border:none;background:#6c5ce7;color:#fff;font-size:12px;width:100%;" onclick="snapshotToday()">üíæ L∆∞u t·ªìn cu·ªëi h√¥m nay l√™n server</button>
    <select id="historySelect" onchange="showHistorySummary()">
      <option value="">-- Ch·ªçn ng√†y xem l·ªãch s·ª≠ --</option>
    </select>
    <div id="historySummary"></div>
  </div>

  <div class="status" id="status"></div>

  <input type="file" id="imgInput" accept="image/*" style="display:none" onchange="handleImageChange(event)">

  <div id="ocrOverlay">
    <div id="ocrBox">
      <h3>K·∫øt qu·∫£ AI ƒë·ªçc ƒë∆∞·ª£c</h3>
      <div id="ocrSummary"></div>
      <pre id="ocrRaw"></pre>
      <button onclick="closeOverlay()">ƒê√≥ng</button>
    </div>
  </div>

  <script>
    // ======= C·∫§U H√åNH BACKEND =======
    // Khi deploy l√™n VPS/domain, ch·ªâ c·∫ßn ƒë·ªïi d√≤ng n√†y:
    const BACKEND = "http://localhost:4000";

    // ======= STATE TO√ÄN C·ª§C =======
    let inventoryData = [];      // d·ªØ li·ªáu t·ªìn kho t·ª´ server cho ng√†y hi·ªán t·∫°i
    let sparkHistory = {};       // {productName: [{dateKey, value}, ...]}
    let currentDateKey = todayKey();
    let currentImageType = null; // "nhap" | "xuat"

    // alias d√πng cho AI OCR map t√™n t·∫Øt ‚Üí t√™n chu·∫©n
    const aliasMap = [
      { key: "duong mia tim",       target: "M√≠a t√≠m" },
      { key: "duong mia",           target: "M√≠a t√≠m" },
      { key: "soc trang to",        target: "S√≥c TrƒÉng To" },
      { key: "duong soc trang to",  target: "S√≥c TrƒÉng To" },
      { key: "soc trang trung",     target: "S√≥c TrƒÉng Trung" },
      { key: "duong soc trang trung", target: "S√≥c TrƒÉng Trung" },
      { key: "duong trung",         target: "Trung" },
      { key: "duong nhuyen",        target: "Nhuy·ªÖn" },
      { key: "duong vang",          target: "V√†ng" },

      { key: "phen xa",             target: "Ph√®n X√°" },
      { key: "phen bi xanh duong",  target: "Ph√®n BI Xanh D∆∞∆°ng" },
      { key: "phen bi xanh la",     target: "Ph√®n BI Xanh L√°" },
      { key: "phen hat cam",        target: "Ph√®n H·∫°t Cam" },
      { key: "phen bi tui",         target: "Ph√®n BI T√∫i" },

      { key: "bi duong",            target: "Bi ƒê∆∞·ªùng" },
      { key: "bi tui 500",          target: "Bi T√∫i 500g" },
      { key: "bi tui 1kg",          target: "Bi T√∫i 1kg" }
    ];

    // ======= H√ÄM TI·ªÜN √çCH =======
    function todayKey() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const da = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${da}`;
    }

    function normalize(str) {
      return str
        .toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function findProductByLine(line) {
      const norm = normalize(line);
      let bestMatch = null;

      aliasMap.forEach(a => {
        if (norm.includes(a.key)) {
          bestMatch = a.target;
        }
      });

      // th·ª≠ kh·ªõp tr·ª±c ti·∫øp v·ªõi t√™n s·∫£n ph·∫©m trong inventoryData
      if (!bestMatch) {
        inventoryData.forEach(p => {
          const nName = normalize(p.productName);
          if (norm.includes(nName)) {
            bestMatch = p.productName;
          }
        });
      }

      return bestMatch;
    }

    // ======= LOAD D·ªÆ LI·ªÜU T·ª™ BACKEND =======
    async function loadInventory() {
      try {
        const res = await fetch(`${BACKEND}/api/inventory?date=${currentDateKey}`);
        inventoryData = await res.json();
        renderList();
      } catch (e) {
        console.error(e);
        document.getElementById("status").innerText =
          "‚ùå Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ server. Ki·ªÉm tra backend & m·∫°ng.";
      }
    }

    async function loadHistoryDates() {
      try {
        const res = await fetch(`${BACKEND}/api/history/dates`);
        const dates = await res.json(); // ["2025-11-25", ...]
        const select = document.getElementById("historySelect");
        const oldVal = select.value;

        select.innerHTML = '<option value="">-- Ch·ªçn ng√†y xem l·ªãch s·ª≠ --</option>';
        dates.forEach(d => {
          const opt = document.createElement("option");
          opt.value = d;
          opt.textContent = d;
          select.appendChild(opt);
        });

        if (dates.includes(oldVal)) select.value = oldVal;

        // ƒë·ªìng th·ªùi build sparkHistory
        await buildSparkHistory(dates);
        renderList(); // c·∫≠p nh·∫≠t sparkline
      } catch (e) {
        console.error(e);
      }
    }

    async function buildSparkHistory(dates) {
      sparkHistory = {};
      if (!Array.isArray(dates) || !dates.length) return;

      // ch·ªâ l·∫•y t·ªëi ƒëa 14 ng√†y g·∫ßn nh·∫•t
      const lastDates = dates.slice(-14);

      const promises = lastDates.map(async d => {
        const r = await fetch(`${BACKEND}/api/history/${d}`);
        const json = await r.json(); // {dateKey, items:[{productName, cuoiBao}]}
        (json.items || []).forEach(it => {
          if (!sparkHistory[it.productName]) {
            sparkHistory[it.productName] = [];
          }
          sparkHistory[it.productName].push({ dateKey: json.dateKey, value: it.cuoiBao });
        });
      });

      await Promise.all(promises);
    }

    // ======= RENDER DANH S√ÅCH =======
    function renderList() {
      const listEl = document.getElementById("list");
      const searchText = document.getElementById("search").value.toLowerCase();
      let html = "";
      let totalKgAll = 0;

      inventoryData.forEach(p => {
        if (searchText && !p.productName.toLowerCase().includes(searchText)) return;

        const {
          productName,
          group,
          kgPerBao,
          tonBao,
          nhapBao,
          xuatBao,
          thucTeBao,
          cuoiBao,
          cuoiKg,
          lechBao
        } = p;

        totalKgAll += cuoiKg;

        const spark = getSparkline(productName);

        html += `
          <div class="card" data-group="${group}">
            <div class="card-header">
              <div>
                <div class="product-title">${productName}</div>
                <div class="group">${group}</div>
                <div class="unit-info">1 bao ‚âà ${kgPerBao} kg</div>
              </div>
            </div>

            <div class="row">
              <div>
                <div class="label">T·ªìn ƒë·∫ßu (bao)</div>
                <input type="number" value="${tonBao}" 
                  oninput="updateField('${productName}','tonBao',this.value)">
              </div>
              <div>
                <div class="label">Nh·∫≠p (bao)</div>
                <input type="number" value="${nhapBao}" 
                  oninput="updateField('${productName}','nhapBao',this.value)">
              </div>
              <div>
                <div class="label">Xu·∫•t (bao)</div>
                <input type="number" value="${xuatBao}" 
                  oninput="updateField('${productName}','xuatBao',this.value)">
              </div>
            </div>

            <div class="row" style="margin-top:4px;">
              <div>
                <div class="label">Th·ª±c t·∫ø ki·ªÉm (bao)</div>
                <input type="number" value="${thucTeBao || ""}"
                  oninput="updateField('${productName}','thucTeBao',this.value)">
              </div>
            </div>

            <div class="result">
              <span class="bold">T·ªìn cu·ªëi l√Ω thuy·∫øt:</span> ${cuoiBao} bao ‚âà ${cuoiKg} kg<br/>
              <span class="bold">Th·ª±c t·∫ø:</span> ${thucTeBao || 0} bao 
              &nbsp;|&nbsp;
              <span class="bold">L·ªách:</span> ${lechBao} bao
            </div>
            <div class="sparkline">üìà L·ªãch s·ª≠ t·ªìn: ${spark}</div>
          </div>
        `;
      });

      listEl.innerHTML = html;
      document.getElementById("totalBox").innerText =
        "T·ªîNG T·ªíN KHO (l√Ω thuy·∫øt): " + totalKgAll + " kg";
    }

    // ======= UPDATE FIELD L√äN SERVER =======
    let updateTimer = null;
    function updateField(productName, field, val) {
      const value = Number(val) || 0;
      // debounce nh·∫π ƒë·ªÉ tr√°nh spam request
      if (updateTimer) clearTimeout(updateTimer);
      updateTimer = setTimeout(() => {
        fetch(`${BACKEND}/api/inventory/update`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            dateKey: currentDateKey,
            productName,
            field,
            value
          })
        })
          .then(r => r.json())
          .then(() => {
            loadInventory();
          })
          .catch(e => console.error(e));
      }, 200);
    }

    // ======= RESET D·ªÆ LI·ªÜU NG√ÄY =======
    async function resetData() {
      if (!confirm("Reset to√†n b·ªô T·ªìn ƒë·∫ßu/Nh·∫≠p/Xu·∫•t/Th·ª±c t·∫ø v·ªÅ 0 cho ng√†y h√¥m nay?")) return;

      // ƒë∆°n gi·∫£n: load danh s√°ch, set t·∫•t c·∫£ v·ªÅ 0
      const promises = inventoryData.map(p =>
        fetch(`${BACKEND}/api/inventory/update`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            dateKey: currentDateKey,
            productName: p.productName,
            field: "tonBao",
            value: 0
          })
        }).then(() =>
          fetch(`${BACKEND}/api/inventory/update`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              dateKey: currentDateKey,
              productName: p.productName,
              field: "nhapBao",
              value: 0
            })
          }).then(() =>
            fetch(`${BACKEND}/api/inventory/update`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                dateKey: currentDateKey,
                productName: p.productName,
                field: "xuatBao",
                value: 0
              })
            }).then(() =>
              fetch(`${BACKEND}/api/inventory/update`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  dateKey: currentDateKey,
                  productName: p.productName,
                  field: "thucTeBao",
                  value: 0
                })
              })
            )
          )
        )
      );

      await Promise.all(promises);
      loadInventory();
    }

    // ======= COPY B√ÅO C√ÅO ZALO =======
    function copyReport() {
      let msg = "üì¶ *B√ÅO C√ÅO T·ªíN KHO CU·ªêI NG√ÄY " + currentDateKey + "*\n\n";
      let totalKgAll = 0;
      let totalLechBao = 0;

      inventoryData.forEach(p => {
        const {
          productName,
          cuoiBao,
          cuoiKg,
          lechBao
        } = p;
        totalKgAll += cuoiKg;
        totalLechBao += lechBao;
        msg += `‚Ä¢ ${productName}: ${cuoiBao} bao (~${cuoiKg} kg), l·ªách ${lechBao} bao\n`;
      });

      msg += `\nT·ªïng t·ªìn kho: ${totalKgAll} kg\n`;
      msg += `T·ªïng l·ªách: ${totalLechBao} bao\n`;

      navigator.clipboard.writeText(msg);
      alert("ƒê√£ copy b√°o c√°o ‚Äì d√°n v√†o Zalo ƒë·ªÉ g·ª≠i!");
    }

    // ======= EXPORT CSV =======
    function exportCSV() {
      let rows = [];
      rows.push([
        "S·∫£n ph·∫©m",
        "Nh√≥m",
        "T·ªìn ƒë·∫ßu (bao)",
        "Nh·∫≠p (bao)",
        "Xu·∫•t (bao)",
        "T·ªìn cu·ªëi (bao)",
        "T·ªìn cu·ªëi (kg)",
        "Th·ª±c t·∫ø (bao)",
        "L·ªách (bao)"
      ]);

      inventoryData.forEach(p => {
        rows.push([
          p.productName,
          p.group,
          p.tonBao,
          p.nhapBao,
          p.xuatBao,
          p.cuoiBao,
          p.cuoiKg,
          p.thucTeBao,
          p.lechBao
        ]);
      });

      const csvContent = rows.map(r => r.join(",")).join("\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `bao_cao_kho_bich_tuyen_${currentDateKey}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ======= SNAPSHOT & L·ªäCH S·ª¨ =======
    async function snapshotToday() {
      try {
        const res = await fetch(`${BACKEND}/api/inventory/snapshot`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ dateKey: currentDateKey })
        });
        await res.json();
        alert("ƒê√£ l∆∞u snapshot t·ªìn cu·ªëi ng√†y " + currentDateKey + " l√™n server.");
        loadHistoryDates();
      } catch (e) {
        console.error(e);
        alert("Kh√¥ng l∆∞u ƒë∆∞·ª£c snapshot, ki·ªÉm tra server.");
      }
    }

    async function showHistorySummary() {
      const sel = document.getElementById("historySelect");
      const dateKey = sel.value;
      const box = document.getElementById("historySummary");
      if (!dateKey) {
        box.innerHTML = "";
        return;
      }
      try {
        const res = await fetch(`${BACKEND}/api/history/${dateKey}`);
        const json = await res.json();
        if (!json.items || !json.items.length) {
          box.innerHTML = "Kh√¥ng c√≥ d·ªØ li·ªáu cho ng√†y n√†y.";
          return;
        }
        let html = `<div><b>T·ªìn cu·ªëi ng√†y ${dateKey}:</b></div><ul>`;
        json.items.forEach(it => {
          html += `<li>${it.productName}: ${it.cuoiBao} bao</li>`;
        });
        html += "</ul>";
        box.innerHTML = html;
      } catch (e) {
        console.error(e);
        box.innerHTML = "L·ªói khi t·∫£i l·ªãch s·ª≠ ng√†y.";
      }
    }

    function getSparkline(productName) {
      const arr = sparkHistory[productName];
      if (!arr || !arr.length) return "(ch∆∞a c√≥ d·ªØ li·ªáu snapshot)";
      const values = arr.map(x => x.value);
      const min = Math.min(...values);
      const max = Math.max(...values);
      if (max === min) return "‚ñá".repeat(Math.min(values.length, 10));
      const blocks = ["‚ñÅ","‚ñÇ","‚ñÉ","‚ñÑ","‚ñÖ","‚ñÜ","‚ñá"];
      let s = "";
      values.forEach(v => {
        const ratio = (v - min) / (max - min);
        const idx = Math.min(blocks.length-1, Math.max(0, Math.floor(ratio * blocks.length)));
        s += blocks[idx];
      });
      return s;
    }

    // ======= AI OCR NH·∫¨P/XU·∫§T =======
    function triggerImage(type) {
      currentImageType = type; // "nhap" or "xuat"
      document.getElementById("imgInput").value = "";
      document.getElementById("imgInput").click();
    }

    function handleImageChange(event) {
      const file = event.target.files[0];
      if (!file) return;

      const status = document.getElementById("status");
      status.innerText = "‚è≥ ƒêang d√πng AI ƒë·ªçc ·∫£nh, vui l√≤ng ch·ªù...";

      Tesseract.recognize(file, "eng", {
        logger: m => {}
      })
      .then(({ data: { text } }) => {
        status.innerText = "‚úÖ AI ƒë√£ ƒë·ªçc xong, ƒëang x·ª≠ l√Ω d·ªØ li·ªáu...";
        applyOcrText(text, currentImageType);
      })
      .catch(err => {
        console.error(err);
        status.innerText = "‚ùå L·ªói khi ƒë·ªçc ·∫£nh. Vui l√≤ng ch·ª•p r√µ h∆°n.";
      });
    }

    async function applyOcrText(text, type) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l);
      let summary = "";
      let items = [];

      lines.forEach(line => {
        const matchQty = line.match(/(\d+)\s*$/);
        if (!matchQty) return;
        const qty = parseInt(matchQty[1], 10);
        if (isNaN(qty) || qty === 0) return;

        const productName = findProductByLine(line);
        if (!productName) {
          summary += `‚ùå Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c: "${line}"\n`;
          return;
        }

        items.push({ productName, qtyBao: qty });
        summary += `‚úî ${productName} ‚Äì c·ªông ${qty} v√†o c·ªôt ${type === "nhap" ? "NH·∫¨P" : "XU·∫§T"}\n`;
      });

      if (items.length) {
        try {
          await fetch(`${BACKEND}/api/inventory/bulk-apply`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              dateKey: currentDateKey,
              type,
              items
            })
          });
          await loadInventory();
          document.getElementById("status").innerText =
            `‚úÖ ƒê√£ c·∫≠p nh·∫≠t ${items.length} d√≤ng t·ª´ ·∫£nh ${type === "nhap" ? "NH·∫¨P" : "XU·∫§T"}.`;
        } catch (e) {
          console.error(e);
          document.getElementById("status").innerText =
            "‚ùå L·ªói khi g·ª≠i d·ªØ li·ªáu OCR l√™n server.";
        }
      } else {
        document.getElementById("status").innerText =
          "‚ö† AI kh√¥ng nh·∫≠n ƒë∆∞·ª£c d√≤ng n√†o ph√π h·ª£p, vui l√≤ng ki·ªÉm tra l·∫°i ·∫£nh.";
      }

      document.getElementById("ocrSummary").innerText = summary || "Kh√¥ng c√≥ d√≤ng n√†o ƒë∆∞·ª£c √°p d·ª•ng.";
      document.getElementById("ocrRaw").innerText = text;
      document.getElementById("ocrOverlay").style.display = "flex";
    }

    function closeOverlay() {
      document.getElementById("ocrOverlay").style.display = "none";
    }

    // ======= KH·ªûI T·∫†O =======
    (async function init() {
      currentDateKey = todayKey();
      await loadInventory();
      await loadHistoryDates();
      document.getElementById("status").innerText =
        "‚úÖ ƒê√£ k·∫øt n·ªëi server " + BACKEND + " cho ng√†y " + currentDateKey;
    })();
  </script>
</body>
</html>
